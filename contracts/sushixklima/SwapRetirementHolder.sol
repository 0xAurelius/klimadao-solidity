// SPDX-License-Identifier: MIT

pragma solidity ^0.8.10;

import "./keepers/KeeperCompatible.sol";
import "../helpers/Ownable.sol";

interface IKlimaRetirementAggregator {

    function retireCarbon(
        address _sourceToken,
        address _poolToken,
        uint256 _amount,
        bool _amountInCarbon,
        address _beneficiaryAddress,
        string memory _beneficiaryString,
        string memory _retirementMessage
    ) external;
}

interface IWrappedAsset {

    function deposit() external payable;
    function balanceOf(address user) external;
    function approve(address guy, uint wad) external returns (bool);
    
}


contract SwapRetirementHolder is KeeperCompatibleInterface, Ownable {

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint public interval;
    uint public lastTimeStamp;
    uint public numPendingRetirementAddresses;
    bool private continueUpKeeping;

    address public WrappedNativeAssetAddress;
    address public sourceCarbonToken;
    
    IKlimaRetirementAggregator public KlimaAggregator;

    mapping (address => uint256) public pendingRetirementAmounts;
    mapping (uint256 => address) public pendingRetirees;

    event intervalUpdated(uint newInterval);
    event aggregatorAddressUpdated(address newAddress);
    event newPendingRetirement(address retiree, uint256 amount);

    constructor(address _KlimaAggregator, uint _interval, address _wrappedNativeAsset, address _carbonToken) {
        KlimaAggregator = IKlimaRetirementAggregator(_KlimaAggregator);

        // set first upkeep check at the interval from now
        lastTimeStamp = block.timestamp + _interval;

        interval = _interval;

        // set native wrapped asset address
        WrappedNativeAssetAddress = _wrappedNativeAsset;

        // set carbon token to use
        // TODO: make this dynamic on upkeep

        sourceCarbonToken = _carbonToken;
    }

    function setKlimaAggregator(address newAggregator) public onlyManager {
        KlimaAggregator = IKlimaRetirementAggregator(newAggregator);
    }

    function setRetirementInterval(uint newInterval) public onlyManager {
        interval = newInterval;
        emit intervalUpdated(interval);
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        if ((block.timestamp - lastTimeStamp) > interval && numPendingRetirementAddresses != 0 ) {
            //lastTimeStamp = block.timestamp;

            //Start from the ending of the array until you get to 0 in case users continue to swap during the upkeep period
            address retiree = pendingRetirees[numPendingRetirementAddresses-1];
            uint amountToRetire = pendingRetirementAmounts[retiree];

            // Deposit the ETH/MATIC to WETH/WMATIC using fallback function of WETH/WMATIC
            IWrappedAsset(WrappedNativeAssetAddress).deposit{value: amountToRetire}();

            //Approve for use by aggregator
            IWrappedAsset(WrappedNativeAssetAddress).approve(address(KlimaAggregator), amountToRetire);

            // Retire tonnage using wrapped token asset; fire and forget no checks on amount

            KlimaAggregator.retireCarbon(WrappedNativeAssetAddress,sourceCarbonToken, amountToRetire, false, retiree, "Sushiswap Green Txn", "Retired using KlimaDAO x Sushi Integration");

            // Reset this user's retirement pending to 0
            pendingRetirees[numPendingRetirementAddresses-1] = address(0);
            pendingRetirementAmounts[retiree] = 0;

            // Reduce counter by 1
            numPendingRetirementAddresses -= 1;



        }
        else if (((block.timestamp - lastTimeStamp) > interval && numPendingRetirementAddresses == 0)) {
            // All users have been retired, reset interval
            lastTimeStamp = block.timestamp;

        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function storePendingRetirement(uint256 amountToStore) public {

        

    }
    // This nifty contract makes use of the fallback function to detect when native ETH/Matic or any native asset is deposited. It automatically sequesters it for retirement use.

    receive() external payable {

        if (pendingRetirementAmounts[msg.sender] == 0){
            pendingRetirees[numPendingRetirementAddresses] = msg.sender;
            pendingRetirementAmounts[msg.sender] += msg.value;
            numPendingRetirementAddresses += 1;
        }
        else {
            pendingRetirementAmounts[msg.sender] += msg.value;
        }
        require(pendingRetirementAmounts[msg.sender] != 0, "Pending Retirement Record Failed: Pending amount is 0");

    }

     fallback() external payable {

        if (pendingRetirementAmounts[msg.sender] == 0){
            pendingRetirees[numPendingRetirementAddresses] = msg.sender;
            pendingRetirementAmounts[msg.sender] += msg.value;
            numPendingRetirementAddresses += 1;
        }
        else {
            pendingRetirementAmounts[msg.sender] += msg.value;
        }
        require(pendingRetirementAmounts[msg.sender] != 0, "Pending Retirement Record Failed: Pending amount is 0");


    }



}
